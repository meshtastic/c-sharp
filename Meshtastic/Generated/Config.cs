// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: config.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Meshtastic.Protobufs {

  /// <summary>Holder for reflection information generated from config.proto</summary>
  public static partial class ConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cgxjb25maWcucHJvdG8i5RUKBkNvbmZpZxImCgZkZXZpY2UYASABKAsyFC5D",
            "b25maWcuRGV2aWNlQ29uZmlnSAASKgoIcG9zaXRpb24YAiABKAsyFi5Db25m",
            "aWcuUG9zaXRpb25Db25maWdIABIkCgVwb3dlchgDIAEoCzITLkNvbmZpZy5Q",
            "b3dlckNvbmZpZ0gAEigKB25ldHdvcmsYBCABKAsyFS5Db25maWcuTmV0d29y",
            "a0NvbmZpZ0gAEigKB2Rpc3BsYXkYBSABKAsyFS5Db25maWcuRGlzcGxheUNv",
            "bmZpZ0gAEiIKBGxvcmEYBiABKAsyEi5Db25maWcuTG9SYUNvbmZpZ0gAEiwK",
            "CWJsdWV0b290aBgHIAEoCzIXLkNvbmZpZy5CbHVldG9vdGhDb25maWdIABrY",
            "AQoMRGV2aWNlQ29uZmlnEicKBHJvbGUYASABKA4yGS5Db25maWcuRGV2aWNl",
            "Q29uZmlnLlJvbGUSFgoOc2VyaWFsX2VuYWJsZWQYAiABKAgSGQoRZGVidWdf",
            "bG9nX2VuYWJsZWQYAyABKAgSEwoLYnV0dG9uX2dwaW8YBCABKA0SEwoLYnV6",
            "emVyX2dwaW8YBSABKA0iQgoEUm9sZRIKCgZDTElFTlQQABIPCgtDTElFTlRf",
            "TVVURRABEgoKBlJPVVRFUhACEhEKDVJPVVRFUl9DTElFTlQQAxqnAwoOUG9z",
            "aXRpb25Db25maWcSHwoXcG9zaXRpb25fYnJvYWRjYXN0X3NlY3MYASABKA0S",
            "KAogcG9zaXRpb25fYnJvYWRjYXN0X3NtYXJ0X2VuYWJsZWQYAiABKAgSFgoO",
            "Zml4ZWRfcG9zaXRpb24YAyABKAgSEwoLZ3BzX2VuYWJsZWQYBCABKAgSGwoT",
            "Z3BzX3VwZGF0ZV9pbnRlcnZhbBgFIAEoDRIYChBncHNfYXR0ZW1wdF90aW1l",
            "GAYgASgNEhYKDnBvc2l0aW9uX2ZsYWdzGAcgASgNEg8KB3J4X2dwaW8YCCAB",
            "KA0SDwoHdHhfZ3BpbxgJIAEoDSKrAQoNUG9zaXRpb25GbGFncxIJCgVVTlNF",
            "VBAAEgwKCEFMVElUVURFEAESEAoMQUxUSVRVREVfTVNMEAISFgoSR0VPSURB",
            "TF9TRVBBUkFUSU9OEAQSBwoDRE9QEAgSCQoFSFZET1AQEBINCglTQVRJTlZJ",
            "RVcQIBIKCgZTRVFfTk8QQBIOCglUSU1FU1RBTVAQgAESDAoHSEVBRElORxCA",
            "AhIKCgVTUEVFRBCABBrlAQoLUG93ZXJDb25maWcSFwoPaXNfcG93ZXJfc2F2",
            "aW5nGAEgASgIEiYKHm9uX2JhdHRlcnlfc2h1dGRvd25fYWZ0ZXJfc2VjcxgC",
            "IAEoDRIfChdhZGNfbXVsdGlwbGllcl9vdmVycmlkZRgDIAEoAhIbChN3YWl0",
            "X2JsdWV0b290aF9zZWNzGAQgASgNEh0KFW1lc2hfc2RzX3RpbWVvdXRfc2Vj",
            "cxgFIAEoDRIQCghzZHNfc2VjcxgGIAEoDRIPCgdsc19zZWNzGAcgASgNEhUK",
            "DW1pbl93YWtlX3NlY3MYCCABKA0axAIKDU5ldHdvcmtDb25maWcSFAoMd2lm",
            "aV9lbmFibGVkGAEgASgIEhEKCXdpZmlfc3NpZBgDIAEoCRIQCgh3aWZpX3Bz",
            "axgEIAEoCRISCgpudHBfc2VydmVyGAUgASgJEhMKC2V0aF9lbmFibGVkGAYg",
            "ASgIEi8KCGV0aF9tb2RlGAcgASgOMh0uQ29uZmlnLk5ldHdvcmtDb25maWcu",
            "RXRoTW9kZRI1CgtpcHY0X2NvbmZpZxgIIAEoCzIgLkNvbmZpZy5OZXR3b3Jr",
            "Q29uZmlnLklwVjRDb25maWcaRgoKSXBWNENvbmZpZxIKCgJpcBgBIAEoBxIP",
            "CgdnYXRld2F5GAIgASgHEg4KBnN1Ym5ldBgDIAEoBxILCgNkbnMYBCABKAci",
            "HwoHRXRoTW9kZRIICgRESENQEAASCgoGU1RBVElDEAEa0QMKDURpc3BsYXlD",
            "b25maWcSFgoOc2NyZWVuX29uX3NlY3MYASABKA0SPQoKZ3BzX2Zvcm1hdBgC",
            "IAEoDjIpLkNvbmZpZy5EaXNwbGF5Q29uZmlnLkdwc0Nvb3JkaW5hdGVGb3Jt",
            "YXQSIQoZYXV0b19zY3JlZW5fY2Fyb3VzZWxfc2VjcxgDIAEoDRIZChFjb21w",
            "YXNzX25vcnRoX3RvcBgEIAEoCBITCgtmbGlwX3NjcmVlbhgFIAEoCBIxCgV1",
            "bml0cxgGIAEoDjIiLkNvbmZpZy5EaXNwbGF5Q29uZmlnLkRpc3BsYXlVbml0",
            "cxIsCgRvbGVkGAcgASgOMh4uQ29uZmlnLkRpc3BsYXlDb25maWcuT2xlZFR5",
            "cGUiTQoTR3BzQ29vcmRpbmF0ZUZvcm1hdBIHCgNERUMQABIHCgNETVMQARIH",
            "CgNVVE0QAhIICgRNR1JTEAMSBwoDT0xDEAQSCAoET1NHUhAFIigKDERpc3Bs",
            "YXlVbml0cxIKCgZNRVRSSUMQABIMCghJTVBFUklBTBABIjwKCE9sZWRUeXBl",
            "Eg0KCU9MRURfQVVUTxAAEhAKDE9MRURfU1NEMTMwNhABEg8KC09MRURfU0gx",
            "MTA2EAIa+gQKCkxvUmFDb25maWcSEgoKdXNlX3ByZXNldBgBIAEoCBI0Cgxt",
            "b2RlbV9wcmVzZXQYAiABKA4yHi5Db25maWcuTG9SYUNvbmZpZy5Nb2RlbVBy",
            "ZXNldBIRCgliYW5kd2lkdGgYAyABKA0SFQoNc3ByZWFkX2ZhY3RvchgEIAEo",
            "DRITCgtjb2RpbmdfcmF0ZRgFIAEoDRIYChBmcmVxdWVuY3lfb2Zmc2V0GAYg",
            "ASgCEi0KBnJlZ2lvbhgHIAEoDjIdLkNvbmZpZy5Mb1JhQ29uZmlnLlJlZ2lv",
            "bkNvZGUSEQoJaG9wX2xpbWl0GAggASgNEhIKCnR4X2VuYWJsZWQYCSABKAgS",
            "EAoIdHhfcG93ZXIYCiABKAUSEwoLY2hhbm5lbF9udW0YCyABKA0SGwoTb3Zl",
            "cnJpZGVfZHV0eV9jeWNsZRgMIAEoCBIXCg9pZ25vcmVfaW5jb21pbmcYZyAD",
            "KA0ikQEKClJlZ2lvbkNvZGUSCQoFVU5TRVQQABIGCgJVUxABEgoKBkVVXzQz",
            "MxACEgoKBkVVXzg2OBADEgYKAkNOEAQSBgoCSlAQBRIHCgNBTloQBhIGCgJL",
            "UhAHEgYKAlRXEAgSBgoCUlUQCRIGCgJJThAKEgoKBk5aXzg2NRALEgYKAlRI",
            "EAwSCwoHTE9SQV8yNBANIoEBCgtNb2RlbVByZXNldBINCglMT05HX0ZBU1QQ",
            "ABINCglMT05HX1NMT1cQARISCg5WRVJZX0xPTkdfU0xPVxACEg8KC01FRElV",
            "TV9TTE9XEAMSDwoLTUVESVVNX0ZBU1QQBBIOCgpTSE9SVF9TTE9XEAUSDgoK",
            "U0hPUlRfRkFTVBAGGqIBCg9CbHVldG9vdGhDb25maWcSDwoHZW5hYmxlZBgB",
            "IAEoCBIxCgRtb2RlGAIgASgOMiMuQ29uZmlnLkJsdWV0b290aENvbmZpZy5Q",
            "YWlyaW5nTW9kZRIRCglmaXhlZF9waW4YAyABKA0iOAoLUGFpcmluZ01vZGUS",
            "DgoKUkFORE9NX1BJThAAEg0KCUZJWEVEX1BJThABEgoKBk5PX1BJThACQhEK",
            "D3BheWxvYWRfdmFyaWFudEJgChNjb20uZ2Vla3N2aWxsZS5tZXNoQgxDb25m",
            "aWdQcm90b3NIA1oiZ2l0aHViLmNvbS9tZXNodGFzdGljL2dvL2dlbmVyYXRl",
            "ZKoCFE1lc2h0YXN0aWMuUHJvdG9idWZzYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config), global::Meshtastic.Protobufs.Config.Parser, new[]{ "Device", "Position", "Power", "Network", "Display", "Lora", "Bluetooth" }, new[]{ "PayloadVariant" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.DeviceConfig), global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Parser, new[]{ "Role", "SerialEnabled", "DebugLogEnabled", "ButtonGpio", "BuzzerGpio" }, null, new[]{ typeof(global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.PositionConfig), global::Meshtastic.Protobufs.Config.Types.PositionConfig.Parser, new[]{ "PositionBroadcastSecs", "PositionBroadcastSmartEnabled", "FixedPosition", "GpsEnabled", "GpsUpdateInterval", "GpsAttemptTime", "PositionFlags", "RxGpio", "TxGpio" }, null, new[]{ typeof(global::Meshtastic.Protobufs.Config.Types.PositionConfig.Types.PositionFlags) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.PowerConfig), global::Meshtastic.Protobufs.Config.Types.PowerConfig.Parser, new[]{ "IsPowerSaving", "OnBatteryShutdownAfterSecs", "AdcMultiplierOverride", "WaitBluetoothSecs", "MeshSdsTimeoutSecs", "SdsSecs", "LsSecs", "MinWakeSecs" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.NetworkConfig), global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Parser, new[]{ "WifiEnabled", "WifiSsid", "WifiPsk", "NtpServer", "EthEnabled", "EthMode", "Ipv4Config" }, null, new[]{ typeof(global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.EthMode) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.IpV4Config), global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.IpV4Config.Parser, new[]{ "Ip", "Gateway", "Subnet", "Dns" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.DisplayConfig), global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Parser, new[]{ "ScreenOnSecs", "GpsFormat", "AutoScreenCarouselSecs", "CompassNorthTop", "FlipScreen", "Units", "Oled" }, null, new[]{ typeof(global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat), typeof(global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits), typeof(global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.LoRaConfig), global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Parser, new[]{ "UsePreset", "ModemPreset", "Bandwidth", "SpreadFactor", "CodingRate", "FrequencyOffset", "Region", "HopLimit", "TxEnabled", "TxPower", "ChannelNum", "OverrideDutyCycle", "IgnoreIncoming" }, null, new[]{ typeof(global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode), typeof(global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.BluetoothConfig), global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Parser, new[]{ "Enabled", "Mode", "FixedPin" }, null, new[]{ typeof(global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode) }, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class Config : pb::IMessage<Config>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Config> _parser = new pb::MessageParser<Config>(() => new Config());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Config> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Meshtastic.Protobufs.ConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Config() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Config(Config other) : this() {
      switch (other.PayloadVariantCase) {
        case PayloadVariantOneofCase.Device:
          Device = other.Device.Clone();
          break;
        case PayloadVariantOneofCase.Position:
          Position = other.Position.Clone();
          break;
        case PayloadVariantOneofCase.Power:
          Power = other.Power.Clone();
          break;
        case PayloadVariantOneofCase.Network:
          Network = other.Network.Clone();
          break;
        case PayloadVariantOneofCase.Display:
          Display = other.Display.Clone();
          break;
        case PayloadVariantOneofCase.Lora:
          Lora = other.Lora.Clone();
          break;
        case PayloadVariantOneofCase.Bluetooth:
          Bluetooth = other.Bluetooth.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Config Clone() {
      return new Config(this);
    }

    /// <summary>Field number for the "device" field.</summary>
    public const int DeviceFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.DeviceConfig Device {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Device ? (global::Meshtastic.Protobufs.Config.Types.DeviceConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Device;
      }
    }

    /// <summary>Field number for the "position" field.</summary>
    public const int PositionFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.PositionConfig Position {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Position ? (global::Meshtastic.Protobufs.Config.Types.PositionConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Position;
      }
    }

    /// <summary>Field number for the "power" field.</summary>
    public const int PowerFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.PowerConfig Power {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Power ? (global::Meshtastic.Protobufs.Config.Types.PowerConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Power;
      }
    }

    /// <summary>Field number for the "network" field.</summary>
    public const int NetworkFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.NetworkConfig Network {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Network ? (global::Meshtastic.Protobufs.Config.Types.NetworkConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Network;
      }
    }

    /// <summary>Field number for the "display" field.</summary>
    public const int DisplayFieldNumber = 5;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.DisplayConfig Display {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Display ? (global::Meshtastic.Protobufs.Config.Types.DisplayConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Display;
      }
    }

    /// <summary>Field number for the "lora" field.</summary>
    public const int LoraFieldNumber = 6;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.LoRaConfig Lora {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Lora ? (global::Meshtastic.Protobufs.Config.Types.LoRaConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Lora;
      }
    }

    /// <summary>Field number for the "bluetooth" field.</summary>
    public const int BluetoothFieldNumber = 7;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.BluetoothConfig Bluetooth {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Bluetooth ? (global::Meshtastic.Protobufs.Config.Types.BluetoothConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Bluetooth;
      }
    }

    private object payloadVariant_;
    /// <summary>Enum of possible cases for the "payload_variant" oneof.</summary>
    public enum PayloadVariantOneofCase {
      None = 0,
      Device = 1,
      Position = 2,
      Power = 3,
      Network = 4,
      Display = 5,
      Lora = 6,
      Bluetooth = 7,
    }
    private PayloadVariantOneofCase payloadVariantCase_ = PayloadVariantOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PayloadVariantOneofCase PayloadVariantCase {
      get { return payloadVariantCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPayloadVariant() {
      payloadVariantCase_ = PayloadVariantOneofCase.None;
      payloadVariant_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Config);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Config other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Device, other.Device)) return false;
      if (!object.Equals(Position, other.Position)) return false;
      if (!object.Equals(Power, other.Power)) return false;
      if (!object.Equals(Network, other.Network)) return false;
      if (!object.Equals(Display, other.Display)) return false;
      if (!object.Equals(Lora, other.Lora)) return false;
      if (!object.Equals(Bluetooth, other.Bluetooth)) return false;
      if (PayloadVariantCase != other.PayloadVariantCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (payloadVariantCase_ == PayloadVariantOneofCase.Device) hash ^= Device.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.Position) hash ^= Position.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.Power) hash ^= Power.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.Network) hash ^= Network.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.Display) hash ^= Display.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.Lora) hash ^= Lora.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.Bluetooth) hash ^= Bluetooth.GetHashCode();
      hash ^= (int) payloadVariantCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (payloadVariantCase_ == PayloadVariantOneofCase.Device) {
        output.WriteRawTag(10);
        output.WriteMessage(Device);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Position) {
        output.WriteRawTag(18);
        output.WriteMessage(Position);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Power) {
        output.WriteRawTag(26);
        output.WriteMessage(Power);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Network) {
        output.WriteRawTag(34);
        output.WriteMessage(Network);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Display) {
        output.WriteRawTag(42);
        output.WriteMessage(Display);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Lora) {
        output.WriteRawTag(50);
        output.WriteMessage(Lora);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Bluetooth) {
        output.WriteRawTag(58);
        output.WriteMessage(Bluetooth);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (payloadVariantCase_ == PayloadVariantOneofCase.Device) {
        output.WriteRawTag(10);
        output.WriteMessage(Device);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Position) {
        output.WriteRawTag(18);
        output.WriteMessage(Position);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Power) {
        output.WriteRawTag(26);
        output.WriteMessage(Power);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Network) {
        output.WriteRawTag(34);
        output.WriteMessage(Network);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Display) {
        output.WriteRawTag(42);
        output.WriteMessage(Display);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Lora) {
        output.WriteRawTag(50);
        output.WriteMessage(Lora);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Bluetooth) {
        output.WriteRawTag(58);
        output.WriteMessage(Bluetooth);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (payloadVariantCase_ == PayloadVariantOneofCase.Device) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Device);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Position) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Position);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Power) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Power);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Network) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Network);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Display) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Display);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Lora) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lora);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Bluetooth) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Bluetooth);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Config other) {
      if (other == null) {
        return;
      }
      switch (other.PayloadVariantCase) {
        case PayloadVariantOneofCase.Device:
          if (Device == null) {
            Device = new global::Meshtastic.Protobufs.Config.Types.DeviceConfig();
          }
          Device.MergeFrom(other.Device);
          break;
        case PayloadVariantOneofCase.Position:
          if (Position == null) {
            Position = new global::Meshtastic.Protobufs.Config.Types.PositionConfig();
          }
          Position.MergeFrom(other.Position);
          break;
        case PayloadVariantOneofCase.Power:
          if (Power == null) {
            Power = new global::Meshtastic.Protobufs.Config.Types.PowerConfig();
          }
          Power.MergeFrom(other.Power);
          break;
        case PayloadVariantOneofCase.Network:
          if (Network == null) {
            Network = new global::Meshtastic.Protobufs.Config.Types.NetworkConfig();
          }
          Network.MergeFrom(other.Network);
          break;
        case PayloadVariantOneofCase.Display:
          if (Display == null) {
            Display = new global::Meshtastic.Protobufs.Config.Types.DisplayConfig();
          }
          Display.MergeFrom(other.Display);
          break;
        case PayloadVariantOneofCase.Lora:
          if (Lora == null) {
            Lora = new global::Meshtastic.Protobufs.Config.Types.LoRaConfig();
          }
          Lora.MergeFrom(other.Lora);
          break;
        case PayloadVariantOneofCase.Bluetooth:
          if (Bluetooth == null) {
            Bluetooth = new global::Meshtastic.Protobufs.Config.Types.BluetoothConfig();
          }
          Bluetooth.MergeFrom(other.Bluetooth);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Meshtastic.Protobufs.Config.Types.DeviceConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.DeviceConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Device) {
              subBuilder.MergeFrom(Device);
            }
            input.ReadMessage(subBuilder);
            Device = subBuilder;
            break;
          }
          case 18: {
            global::Meshtastic.Protobufs.Config.Types.PositionConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.PositionConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Position) {
              subBuilder.MergeFrom(Position);
            }
            input.ReadMessage(subBuilder);
            Position = subBuilder;
            break;
          }
          case 26: {
            global::Meshtastic.Protobufs.Config.Types.PowerConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.PowerConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Power) {
              subBuilder.MergeFrom(Power);
            }
            input.ReadMessage(subBuilder);
            Power = subBuilder;
            break;
          }
          case 34: {
            global::Meshtastic.Protobufs.Config.Types.NetworkConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.NetworkConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Network) {
              subBuilder.MergeFrom(Network);
            }
            input.ReadMessage(subBuilder);
            Network = subBuilder;
            break;
          }
          case 42: {
            global::Meshtastic.Protobufs.Config.Types.DisplayConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.DisplayConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Display) {
              subBuilder.MergeFrom(Display);
            }
            input.ReadMessage(subBuilder);
            Display = subBuilder;
            break;
          }
          case 50: {
            global::Meshtastic.Protobufs.Config.Types.LoRaConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.LoRaConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Lora) {
              subBuilder.MergeFrom(Lora);
            }
            input.ReadMessage(subBuilder);
            Lora = subBuilder;
            break;
          }
          case 58: {
            global::Meshtastic.Protobufs.Config.Types.BluetoothConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.BluetoothConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Bluetooth) {
              subBuilder.MergeFrom(Bluetooth);
            }
            input.ReadMessage(subBuilder);
            Bluetooth = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Meshtastic.Protobufs.Config.Types.DeviceConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.DeviceConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Device) {
              subBuilder.MergeFrom(Device);
            }
            input.ReadMessage(subBuilder);
            Device = subBuilder;
            break;
          }
          case 18: {
            global::Meshtastic.Protobufs.Config.Types.PositionConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.PositionConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Position) {
              subBuilder.MergeFrom(Position);
            }
            input.ReadMessage(subBuilder);
            Position = subBuilder;
            break;
          }
          case 26: {
            global::Meshtastic.Protobufs.Config.Types.PowerConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.PowerConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Power) {
              subBuilder.MergeFrom(Power);
            }
            input.ReadMessage(subBuilder);
            Power = subBuilder;
            break;
          }
          case 34: {
            global::Meshtastic.Protobufs.Config.Types.NetworkConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.NetworkConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Network) {
              subBuilder.MergeFrom(Network);
            }
            input.ReadMessage(subBuilder);
            Network = subBuilder;
            break;
          }
          case 42: {
            global::Meshtastic.Protobufs.Config.Types.DisplayConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.DisplayConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Display) {
              subBuilder.MergeFrom(Display);
            }
            input.ReadMessage(subBuilder);
            Display = subBuilder;
            break;
          }
          case 50: {
            global::Meshtastic.Protobufs.Config.Types.LoRaConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.LoRaConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Lora) {
              subBuilder.MergeFrom(Lora);
            }
            input.ReadMessage(subBuilder);
            Lora = subBuilder;
            break;
          }
          case 58: {
            global::Meshtastic.Protobufs.Config.Types.BluetoothConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.BluetoothConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Bluetooth) {
              subBuilder.MergeFrom(Bluetooth);
            }
            input.ReadMessage(subBuilder);
            Bluetooth = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Config message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      ///
      /// Configuration
      /// </summary>
      public sealed partial class DeviceConfig : pb::IMessage<DeviceConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<DeviceConfig> _parser = new pb::MessageParser<DeviceConfig>(() => new DeviceConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<DeviceConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DeviceConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DeviceConfig(DeviceConfig other) : this() {
          role_ = other.role_;
          serialEnabled_ = other.serialEnabled_;
          debugLogEnabled_ = other.debugLogEnabled_;
          buttonGpio_ = other.buttonGpio_;
          buzzerGpio_ = other.buzzerGpio_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DeviceConfig Clone() {
          return new DeviceConfig(this);
        }

        /// <summary>Field number for the "role" field.</summary>
        public const int RoleFieldNumber = 1;
        private global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role role_ = global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role.Client;
        /// <summary>
        ///
        /// Sets the role of node
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role Role {
          get { return role_; }
          set {
            role_ = value;
          }
        }

        /// <summary>Field number for the "serial_enabled" field.</summary>
        public const int SerialEnabledFieldNumber = 2;
        private bool serialEnabled_;
        /// <summary>
        ///
        /// Disabling this will disable the SerialConsole by not initilizing the StreamAPI
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool SerialEnabled {
          get { return serialEnabled_; }
          set {
            serialEnabled_ = value;
          }
        }

        /// <summary>Field number for the "debug_log_enabled" field.</summary>
        public const int DebugLogEnabledFieldNumber = 3;
        private bool debugLogEnabled_;
        /// <summary>
        ///
        /// By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
        /// Set this to true to leave the debug log outputting even when API is active.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool DebugLogEnabled {
          get { return debugLogEnabled_; }
          set {
            debugLogEnabled_ = value;
          }
        }

        /// <summary>Field number for the "button_gpio" field.</summary>
        public const int ButtonGpioFieldNumber = 4;
        private uint buttonGpio_;
        /// <summary>
        ///
        /// For boards without a hard wired button, this is the pin number that will be used
        /// Boards that have more than one button can swap the function with this one. defaults to BUTTON_PIN if defined.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint ButtonGpio {
          get { return buttonGpio_; }
          set {
            buttonGpio_ = value;
          }
        }

        /// <summary>Field number for the "buzzer_gpio" field.</summary>
        public const int BuzzerGpioFieldNumber = 5;
        private uint buzzerGpio_;
        /// <summary>
        ///
        /// For boards without a PWM buzzer, this is the pin number that will be used
        /// Defaults to PIN_BUZZER if defined.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint BuzzerGpio {
          get { return buzzerGpio_; }
          set {
            buzzerGpio_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as DeviceConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(DeviceConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Role != other.Role) return false;
          if (SerialEnabled != other.SerialEnabled) return false;
          if (DebugLogEnabled != other.DebugLogEnabled) return false;
          if (ButtonGpio != other.ButtonGpio) return false;
          if (BuzzerGpio != other.BuzzerGpio) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Role != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role.Client) hash ^= Role.GetHashCode();
          if (SerialEnabled != false) hash ^= SerialEnabled.GetHashCode();
          if (DebugLogEnabled != false) hash ^= DebugLogEnabled.GetHashCode();
          if (ButtonGpio != 0) hash ^= ButtonGpio.GetHashCode();
          if (BuzzerGpio != 0) hash ^= BuzzerGpio.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Role != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role.Client) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Role);
          }
          if (SerialEnabled != false) {
            output.WriteRawTag(16);
            output.WriteBool(SerialEnabled);
          }
          if (DebugLogEnabled != false) {
            output.WriteRawTag(24);
            output.WriteBool(DebugLogEnabled);
          }
          if (ButtonGpio != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(ButtonGpio);
          }
          if (BuzzerGpio != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(BuzzerGpio);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Role != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role.Client) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Role);
          }
          if (SerialEnabled != false) {
            output.WriteRawTag(16);
            output.WriteBool(SerialEnabled);
          }
          if (DebugLogEnabled != false) {
            output.WriteRawTag(24);
            output.WriteBool(DebugLogEnabled);
          }
          if (ButtonGpio != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(ButtonGpio);
          }
          if (BuzzerGpio != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(BuzzerGpio);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Role != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role.Client) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Role);
          }
          if (SerialEnabled != false) {
            size += 1 + 1;
          }
          if (DebugLogEnabled != false) {
            size += 1 + 1;
          }
          if (ButtonGpio != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ButtonGpio);
          }
          if (BuzzerGpio != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BuzzerGpio);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(DeviceConfig other) {
          if (other == null) {
            return;
          }
          if (other.Role != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role.Client) {
            Role = other.Role;
          }
          if (other.SerialEnabled != false) {
            SerialEnabled = other.SerialEnabled;
          }
          if (other.DebugLogEnabled != false) {
            DebugLogEnabled = other.DebugLogEnabled;
          }
          if (other.ButtonGpio != 0) {
            ButtonGpio = other.ButtonGpio;
          }
          if (other.BuzzerGpio != 0) {
            BuzzerGpio = other.BuzzerGpio;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Role = (global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role) input.ReadEnum();
                break;
              }
              case 16: {
                SerialEnabled = input.ReadBool();
                break;
              }
              case 24: {
                DebugLogEnabled = input.ReadBool();
                break;
              }
              case 32: {
                ButtonGpio = input.ReadUInt32();
                break;
              }
              case 40: {
                BuzzerGpio = input.ReadUInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Role = (global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role) input.ReadEnum();
                break;
              }
              case 16: {
                SerialEnabled = input.ReadBool();
                break;
              }
              case 24: {
                DebugLogEnabled = input.ReadBool();
                break;
              }
              case 32: {
                ButtonGpio = input.ReadUInt32();
                break;
              }
              case 40: {
                BuzzerGpio = input.ReadUInt32();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the DeviceConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          ///
          /// Defines the device's role on the Mesh network
          /// </summary>
          public enum Role {
            /// <summary>
            ///
            /// Client device role
            /// </summary>
            [pbr::OriginalName("CLIENT")] Client = 0,
            /// <summary>
            ///
            /// Client Mute device role
            ///   Same as a client except packets will not hop over this node, does not contribute to routing packets for mesh.
            /// </summary>
            [pbr::OriginalName("CLIENT_MUTE")] ClientMute = 1,
            /// <summary>
            ///
            /// Router device role.
            ///   Mesh packets will prefer to be routed over this node. This node will not be used by client apps. 
            ///   The wifi/ble radios and the oled screen will be put to sleep.
            /// </summary>
            [pbr::OriginalName("ROUTER")] Router = 2,
            /// <summary>
            ///
            /// Router Client device role
            ///   Mesh packets will prefer to be routed over this node. The Router Client can be used as both a Router and an app connected Client.
            /// </summary>
            [pbr::OriginalName("ROUTER_CLIENT")] RouterClient = 3,
          }

        }
        #endregion

      }

      /// <summary>
      ///
      /// Position Config
      /// </summary>
      public sealed partial class PositionConfig : pb::IMessage<PositionConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<PositionConfig> _parser = new pb::MessageParser<PositionConfig>(() => new PositionConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<PositionConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PositionConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PositionConfig(PositionConfig other) : this() {
          positionBroadcastSecs_ = other.positionBroadcastSecs_;
          positionBroadcastSmartEnabled_ = other.positionBroadcastSmartEnabled_;
          fixedPosition_ = other.fixedPosition_;
          gpsEnabled_ = other.gpsEnabled_;
          gpsUpdateInterval_ = other.gpsUpdateInterval_;
          gpsAttemptTime_ = other.gpsAttemptTime_;
          positionFlags_ = other.positionFlags_;
          rxGpio_ = other.rxGpio_;
          txGpio_ = other.txGpio_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PositionConfig Clone() {
          return new PositionConfig(this);
        }

        /// <summary>Field number for the "position_broadcast_secs" field.</summary>
        public const int PositionBroadcastSecsFieldNumber = 1;
        private uint positionBroadcastSecs_;
        /// <summary>
        ///
        /// We should send our position this often (but only if it has changed significantly)
        /// Defaults to 15 minutes
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint PositionBroadcastSecs {
          get { return positionBroadcastSecs_; }
          set {
            positionBroadcastSecs_ = value;
          }
        }

        /// <summary>Field number for the "position_broadcast_smart_enabled" field.</summary>
        public const int PositionBroadcastSmartEnabledFieldNumber = 2;
        private bool positionBroadcastSmartEnabled_;
        /// <summary>
        ///
        /// Adaptive position braoadcast, which is now the default.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool PositionBroadcastSmartEnabled {
          get { return positionBroadcastSmartEnabled_; }
          set {
            positionBroadcastSmartEnabled_ = value;
          }
        }

        /// <summary>Field number for the "fixed_position" field.</summary>
        public const int FixedPositionFieldNumber = 3;
        private bool fixedPosition_;
        /// <summary>
        ///
        /// If set, this node is at a fixed position.
        /// We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
        /// The lat/lon/alt can be set by an internal GPS or with the help of the app.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool FixedPosition {
          get { return fixedPosition_; }
          set {
            fixedPosition_ = value;
          }
        }

        /// <summary>Field number for the "gps_enabled" field.</summary>
        public const int GpsEnabledFieldNumber = 4;
        private bool gpsEnabled_;
        /// <summary>
        ///
        /// Is GPS enabled for this node?
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool GpsEnabled {
          get { return gpsEnabled_; }
          set {
            gpsEnabled_ = value;
          }
        }

        /// <summary>Field number for the "gps_update_interval" field.</summary>
        public const int GpsUpdateIntervalFieldNumber = 5;
        private uint gpsUpdateInterval_;
        /// <summary>
        ///
        /// How often should we try to get GPS position (in seconds)
        /// or zero for the default of once every 30 seconds
        /// or a very large value (maxint) to update only once at boot.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint GpsUpdateInterval {
          get { return gpsUpdateInterval_; }
          set {
            gpsUpdateInterval_ = value;
          }
        }

        /// <summary>Field number for the "gps_attempt_time" field.</summary>
        public const int GpsAttemptTimeFieldNumber = 6;
        private uint gpsAttemptTime_;
        /// <summary>
        ///
        /// How long should we try to get our position during each gps_update_interval attempt?  (in seconds)
        /// Or if zero, use the default of 30 seconds.
        /// If we don't get a new gps fix in that time, the gps will be put into sleep until  the next gps_update_rate
        /// window.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint GpsAttemptTime {
          get { return gpsAttemptTime_; }
          set {
            gpsAttemptTime_ = value;
          }
        }

        /// <summary>Field number for the "position_flags" field.</summary>
        public const int PositionFlagsFieldNumber = 7;
        private uint positionFlags_;
        /// <summary>
        ///
        /// Bit field of boolean configuration options for POSITION messages
        /// (bitwise OR of PositionFlags)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint PositionFlags {
          get { return positionFlags_; }
          set {
            positionFlags_ = value;
          }
        }

        /// <summary>Field number for the "rx_gpio" field.</summary>
        public const int RxGpioFieldNumber = 8;
        private uint rxGpio_;
        /// <summary>
        ///
        /// (Re)define GPS_RX_PIN for your board.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint RxGpio {
          get { return rxGpio_; }
          set {
            rxGpio_ = value;
          }
        }

        /// <summary>Field number for the "tx_gpio" field.</summary>
        public const int TxGpioFieldNumber = 9;
        private uint txGpio_;
        /// <summary>
        ///
        /// (Re)define GPS_TX_PIN for your board.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint TxGpio {
          get { return txGpio_; }
          set {
            txGpio_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as PositionConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(PositionConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (PositionBroadcastSecs != other.PositionBroadcastSecs) return false;
          if (PositionBroadcastSmartEnabled != other.PositionBroadcastSmartEnabled) return false;
          if (FixedPosition != other.FixedPosition) return false;
          if (GpsEnabled != other.GpsEnabled) return false;
          if (GpsUpdateInterval != other.GpsUpdateInterval) return false;
          if (GpsAttemptTime != other.GpsAttemptTime) return false;
          if (PositionFlags != other.PositionFlags) return false;
          if (RxGpio != other.RxGpio) return false;
          if (TxGpio != other.TxGpio) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (PositionBroadcastSecs != 0) hash ^= PositionBroadcastSecs.GetHashCode();
          if (PositionBroadcastSmartEnabled != false) hash ^= PositionBroadcastSmartEnabled.GetHashCode();
          if (FixedPosition != false) hash ^= FixedPosition.GetHashCode();
          if (GpsEnabled != false) hash ^= GpsEnabled.GetHashCode();
          if (GpsUpdateInterval != 0) hash ^= GpsUpdateInterval.GetHashCode();
          if (GpsAttemptTime != 0) hash ^= GpsAttemptTime.GetHashCode();
          if (PositionFlags != 0) hash ^= PositionFlags.GetHashCode();
          if (RxGpio != 0) hash ^= RxGpio.GetHashCode();
          if (TxGpio != 0) hash ^= TxGpio.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (PositionBroadcastSecs != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(PositionBroadcastSecs);
          }
          if (PositionBroadcastSmartEnabled != false) {
            output.WriteRawTag(16);
            output.WriteBool(PositionBroadcastSmartEnabled);
          }
          if (FixedPosition != false) {
            output.WriteRawTag(24);
            output.WriteBool(FixedPosition);
          }
          if (GpsEnabled != false) {
            output.WriteRawTag(32);
            output.WriteBool(GpsEnabled);
          }
          if (GpsUpdateInterval != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(GpsUpdateInterval);
          }
          if (GpsAttemptTime != 0) {
            output.WriteRawTag(48);
            output.WriteUInt32(GpsAttemptTime);
          }
          if (PositionFlags != 0) {
            output.WriteRawTag(56);
            output.WriteUInt32(PositionFlags);
          }
          if (RxGpio != 0) {
            output.WriteRawTag(64);
            output.WriteUInt32(RxGpio);
          }
          if (TxGpio != 0) {
            output.WriteRawTag(72);
            output.WriteUInt32(TxGpio);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (PositionBroadcastSecs != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(PositionBroadcastSecs);
          }
          if (PositionBroadcastSmartEnabled != false) {
            output.WriteRawTag(16);
            output.WriteBool(PositionBroadcastSmartEnabled);
          }
          if (FixedPosition != false) {
            output.WriteRawTag(24);
            output.WriteBool(FixedPosition);
          }
          if (GpsEnabled != false) {
            output.WriteRawTag(32);
            output.WriteBool(GpsEnabled);
          }
          if (GpsUpdateInterval != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(GpsUpdateInterval);
          }
          if (GpsAttemptTime != 0) {
            output.WriteRawTag(48);
            output.WriteUInt32(GpsAttemptTime);
          }
          if (PositionFlags != 0) {
            output.WriteRawTag(56);
            output.WriteUInt32(PositionFlags);
          }
          if (RxGpio != 0) {
            output.WriteRawTag(64);
            output.WriteUInt32(RxGpio);
          }
          if (TxGpio != 0) {
            output.WriteRawTag(72);
            output.WriteUInt32(TxGpio);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (PositionBroadcastSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PositionBroadcastSecs);
          }
          if (PositionBroadcastSmartEnabled != false) {
            size += 1 + 1;
          }
          if (FixedPosition != false) {
            size += 1 + 1;
          }
          if (GpsEnabled != false) {
            size += 1 + 1;
          }
          if (GpsUpdateInterval != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(GpsUpdateInterval);
          }
          if (GpsAttemptTime != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(GpsAttemptTime);
          }
          if (PositionFlags != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PositionFlags);
          }
          if (RxGpio != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RxGpio);
          }
          if (TxGpio != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TxGpio);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(PositionConfig other) {
          if (other == null) {
            return;
          }
          if (other.PositionBroadcastSecs != 0) {
            PositionBroadcastSecs = other.PositionBroadcastSecs;
          }
          if (other.PositionBroadcastSmartEnabled != false) {
            PositionBroadcastSmartEnabled = other.PositionBroadcastSmartEnabled;
          }
          if (other.FixedPosition != false) {
            FixedPosition = other.FixedPosition;
          }
          if (other.GpsEnabled != false) {
            GpsEnabled = other.GpsEnabled;
          }
          if (other.GpsUpdateInterval != 0) {
            GpsUpdateInterval = other.GpsUpdateInterval;
          }
          if (other.GpsAttemptTime != 0) {
            GpsAttemptTime = other.GpsAttemptTime;
          }
          if (other.PositionFlags != 0) {
            PositionFlags = other.PositionFlags;
          }
          if (other.RxGpio != 0) {
            RxGpio = other.RxGpio;
          }
          if (other.TxGpio != 0) {
            TxGpio = other.TxGpio;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                PositionBroadcastSecs = input.ReadUInt32();
                break;
              }
              case 16: {
                PositionBroadcastSmartEnabled = input.ReadBool();
                break;
              }
              case 24: {
                FixedPosition = input.ReadBool();
                break;
              }
              case 32: {
                GpsEnabled = input.ReadBool();
                break;
              }
              case 40: {
                GpsUpdateInterval = input.ReadUInt32();
                break;
              }
              case 48: {
                GpsAttemptTime = input.ReadUInt32();
                break;
              }
              case 56: {
                PositionFlags = input.ReadUInt32();
                break;
              }
              case 64: {
                RxGpio = input.ReadUInt32();
                break;
              }
              case 72: {
                TxGpio = input.ReadUInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                PositionBroadcastSecs = input.ReadUInt32();
                break;
              }
              case 16: {
                PositionBroadcastSmartEnabled = input.ReadBool();
                break;
              }
              case 24: {
                FixedPosition = input.ReadBool();
                break;
              }
              case 32: {
                GpsEnabled = input.ReadBool();
                break;
              }
              case 40: {
                GpsUpdateInterval = input.ReadUInt32();
                break;
              }
              case 48: {
                GpsAttemptTime = input.ReadUInt32();
                break;
              }
              case 56: {
                PositionFlags = input.ReadUInt32();
                break;
              }
              case 64: {
                RxGpio = input.ReadUInt32();
                break;
              }
              case 72: {
                TxGpio = input.ReadUInt32();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the PositionConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          ///
          /// Bit field of boolean configuration options, indicating which optional
          ///   fields to include when assembling POSITION messages
          /// Longitude and latitude are always included (also time if GPS-synced)
          /// NOTE: the more fields are included, the larger the message will be -
          ///   leading to longer airtime and a higher risk of packet loss
          /// </summary>
          public enum PositionFlags {
            /// <summary>
            ///
            /// Required for compilation
            /// </summary>
            [pbr::OriginalName("UNSET")] Unset = 0,
            /// <summary>
            ///
            /// Include an altitude value (if available)
            /// </summary>
            [pbr::OriginalName("ALTITUDE")] Altitude = 1,
            /// <summary>
            ///
            /// Altitude value is MSL
            /// </summary>
            [pbr::OriginalName("ALTITUDE_MSL")] AltitudeMsl = 2,
            /// <summary>
            ///
            /// Include geoidal separation
            /// </summary>
            [pbr::OriginalName("GEOIDAL_SEPARATION")] GeoidalSeparation = 4,
            /// <summary>
            ///
            /// Include the DOP value ; PDOP used by default, see below
            /// </summary>
            [pbr::OriginalName("DOP")] Dop = 8,
            /// <summary>
            ///
            /// If POS_DOP set, send separate HDOP / VDOP values instead of PDOP
            /// </summary>
            [pbr::OriginalName("HVDOP")] Hvdop = 16,
            /// <summary>
            ///
            /// Include number of "satellites in view"
            /// </summary>
            [pbr::OriginalName("SATINVIEW")] Satinview = 32,
            /// <summary>
            ///
            /// Include a sequence number incremented per packet
            /// </summary>
            [pbr::OriginalName("SEQ_NO")] SeqNo = 64,
            /// <summary>
            ///
            /// Include positional timestamp (from GPS solution)
            /// </summary>
            [pbr::OriginalName("TIMESTAMP")] Timestamp = 128,
            /// <summary>
            ///
            /// Include positional heading
            /// Intended for use with vehicle not walking speeds
            /// walking speeds are likely to be error prone like the compass
            /// </summary>
            [pbr::OriginalName("HEADING")] Heading = 256,
            /// <summary>
            ///
            /// Include positional speed
            /// Intended for use with vehicle not walking speeds
            /// walking speeds are likely to be error prone like the compass
            /// </summary>
            [pbr::OriginalName("SPEED")] Speed = 512,
          }

        }
        #endregion

      }

      /// <summary>
      ///
      /// Power Config\
      /// See [Power Config](/docs/settings/config/power) for additional power config details.
      /// </summary>
      public sealed partial class PowerConfig : pb::IMessage<PowerConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<PowerConfig> _parser = new pb::MessageParser<PowerConfig>(() => new PowerConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<PowerConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PowerConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PowerConfig(PowerConfig other) : this() {
          isPowerSaving_ = other.isPowerSaving_;
          onBatteryShutdownAfterSecs_ = other.onBatteryShutdownAfterSecs_;
          adcMultiplierOverride_ = other.adcMultiplierOverride_;
          waitBluetoothSecs_ = other.waitBluetoothSecs_;
          meshSdsTimeoutSecs_ = other.meshSdsTimeoutSecs_;
          sdsSecs_ = other.sdsSecs_;
          lsSecs_ = other.lsSecs_;
          minWakeSecs_ = other.minWakeSecs_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PowerConfig Clone() {
          return new PowerConfig(this);
        }

        /// <summary>Field number for the "is_power_saving" field.</summary>
        public const int IsPowerSavingFieldNumber = 1;
        private bool isPowerSaving_;
        /// <summary>
        ///
        /// If set, we are powered from a low-current source (i.e. solar), so even if it looks like we have power flowing in
        /// we should try to minimize power consumption as much as possible.
        /// YOU DO NOT NEED TO SET THIS IF YOU'VE set is_router (it is implied in that case).
        /// Advanced Option
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool IsPowerSaving {
          get { return isPowerSaving_; }
          set {
            isPowerSaving_ = value;
          }
        }

        /// <summary>Field number for the "on_battery_shutdown_after_secs" field.</summary>
        public const int OnBatteryShutdownAfterSecsFieldNumber = 2;
        private uint onBatteryShutdownAfterSecs_;
        /// <summary>
        ///
        /// If non-zero, the device will fully power off this many seconds after external power is removed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint OnBatteryShutdownAfterSecs {
          get { return onBatteryShutdownAfterSecs_; }
          set {
            onBatteryShutdownAfterSecs_ = value;
          }
        }

        /// <summary>Field number for the "adc_multiplier_override" field.</summary>
        public const int AdcMultiplierOverrideFieldNumber = 3;
        private float adcMultiplierOverride_;
        /// <summary>
        ///
        /// Ratio of voltage divider for battery pin eg. 3.20 (R1=100k, R2=220k)
        /// Overrides the ADC_MULTIPLIER defined in variant for battery voltage calculation.
        /// Should be set to floating point value between 2 and 4
        /// Fixes issues on Heltec v2
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float AdcMultiplierOverride {
          get { return adcMultiplierOverride_; }
          set {
            adcMultiplierOverride_ = value;
          }
        }

        /// <summary>Field number for the "wait_bluetooth_secs" field.</summary>
        public const int WaitBluetoothSecsFieldNumber = 4;
        private uint waitBluetoothSecs_;
        /// <summary>
        ///
        /// Wait Bluetooth Seconds
        /// The number of seconds for to wait before turning off BLE in No Bluetooth states
        /// 0 for default of 1 minute
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint WaitBluetoothSecs {
          get { return waitBluetoothSecs_; }
          set {
            waitBluetoothSecs_ = value;
          }
        }

        /// <summary>Field number for the "mesh_sds_timeout_secs" field.</summary>
        public const int MeshSdsTimeoutSecsFieldNumber = 5;
        private uint meshSdsTimeoutSecs_;
        /// <summary>
        ///
        /// Mesh Super Deep Sleep Timeout Seconds
        /// While in Light Sleep if this value is exceeded we will lower into super deep sleep 
        /// for sds_secs (default 1 year) or a button press
        /// 0 for default of two hours, MAXUINT for disabled
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint MeshSdsTimeoutSecs {
          get { return meshSdsTimeoutSecs_; }
          set {
            meshSdsTimeoutSecs_ = value;
          }
        }

        /// <summary>Field number for the "sds_secs" field.</summary>
        public const int SdsSecsFieldNumber = 6;
        private uint sdsSecs_;
        /// <summary>
        ///
        /// Super Deep Sleep Seconds
        /// While in Light Sleep if mesh_sds_timeout_secs is exceeded we will lower into super deep sleep
        /// for this value (default 1 year) or a button press
        /// 0 for default of one year
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint SdsSecs {
          get { return sdsSecs_; }
          set {
            sdsSecs_ = value;
          }
        }

        /// <summary>Field number for the "ls_secs" field.</summary>
        public const int LsSecsFieldNumber = 7;
        private uint lsSecs_;
        /// <summary>
        ///
        /// Light Sleep Seconds
        /// In light sleep the CPU is suspended, LoRa radio is on, BLE is off an GPS is on
        /// ESP32 Only
        /// 0 for default of 300
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint LsSecs {
          get { return lsSecs_; }
          set {
            lsSecs_ = value;
          }
        }

        /// <summary>Field number for the "min_wake_secs" field.</summary>
        public const int MinWakeSecsFieldNumber = 8;
        private uint minWakeSecs_;
        /// <summary>
        ///
        /// Minimum Wake Seconds
        /// While in light sleep when we receive packets on the LoRa radio we will wake and handle them and stay awake in no BLE mode for this value
        /// 0 for default of 10 seconds
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint MinWakeSecs {
          get { return minWakeSecs_; }
          set {
            minWakeSecs_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as PowerConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(PowerConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (IsPowerSaving != other.IsPowerSaving) return false;
          if (OnBatteryShutdownAfterSecs != other.OnBatteryShutdownAfterSecs) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AdcMultiplierOverride, other.AdcMultiplierOverride)) return false;
          if (WaitBluetoothSecs != other.WaitBluetoothSecs) return false;
          if (MeshSdsTimeoutSecs != other.MeshSdsTimeoutSecs) return false;
          if (SdsSecs != other.SdsSecs) return false;
          if (LsSecs != other.LsSecs) return false;
          if (MinWakeSecs != other.MinWakeSecs) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (IsPowerSaving != false) hash ^= IsPowerSaving.GetHashCode();
          if (OnBatteryShutdownAfterSecs != 0) hash ^= OnBatteryShutdownAfterSecs.GetHashCode();
          if (AdcMultiplierOverride != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AdcMultiplierOverride);
          if (WaitBluetoothSecs != 0) hash ^= WaitBluetoothSecs.GetHashCode();
          if (MeshSdsTimeoutSecs != 0) hash ^= MeshSdsTimeoutSecs.GetHashCode();
          if (SdsSecs != 0) hash ^= SdsSecs.GetHashCode();
          if (LsSecs != 0) hash ^= LsSecs.GetHashCode();
          if (MinWakeSecs != 0) hash ^= MinWakeSecs.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (IsPowerSaving != false) {
            output.WriteRawTag(8);
            output.WriteBool(IsPowerSaving);
          }
          if (OnBatteryShutdownAfterSecs != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(OnBatteryShutdownAfterSecs);
          }
          if (AdcMultiplierOverride != 0F) {
            output.WriteRawTag(29);
            output.WriteFloat(AdcMultiplierOverride);
          }
          if (WaitBluetoothSecs != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(WaitBluetoothSecs);
          }
          if (MeshSdsTimeoutSecs != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(MeshSdsTimeoutSecs);
          }
          if (SdsSecs != 0) {
            output.WriteRawTag(48);
            output.WriteUInt32(SdsSecs);
          }
          if (LsSecs != 0) {
            output.WriteRawTag(56);
            output.WriteUInt32(LsSecs);
          }
          if (MinWakeSecs != 0) {
            output.WriteRawTag(64);
            output.WriteUInt32(MinWakeSecs);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (IsPowerSaving != false) {
            output.WriteRawTag(8);
            output.WriteBool(IsPowerSaving);
          }
          if (OnBatteryShutdownAfterSecs != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(OnBatteryShutdownAfterSecs);
          }
          if (AdcMultiplierOverride != 0F) {
            output.WriteRawTag(29);
            output.WriteFloat(AdcMultiplierOverride);
          }
          if (WaitBluetoothSecs != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(WaitBluetoothSecs);
          }
          if (MeshSdsTimeoutSecs != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(MeshSdsTimeoutSecs);
          }
          if (SdsSecs != 0) {
            output.WriteRawTag(48);
            output.WriteUInt32(SdsSecs);
          }
          if (LsSecs != 0) {
            output.WriteRawTag(56);
            output.WriteUInt32(LsSecs);
          }
          if (MinWakeSecs != 0) {
            output.WriteRawTag(64);
            output.WriteUInt32(MinWakeSecs);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (IsPowerSaving != false) {
            size += 1 + 1;
          }
          if (OnBatteryShutdownAfterSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(OnBatteryShutdownAfterSecs);
          }
          if (AdcMultiplierOverride != 0F) {
            size += 1 + 4;
          }
          if (WaitBluetoothSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WaitBluetoothSecs);
          }
          if (MeshSdsTimeoutSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MeshSdsTimeoutSecs);
          }
          if (SdsSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SdsSecs);
          }
          if (LsSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LsSecs);
          }
          if (MinWakeSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MinWakeSecs);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(PowerConfig other) {
          if (other == null) {
            return;
          }
          if (other.IsPowerSaving != false) {
            IsPowerSaving = other.IsPowerSaving;
          }
          if (other.OnBatteryShutdownAfterSecs != 0) {
            OnBatteryShutdownAfterSecs = other.OnBatteryShutdownAfterSecs;
          }
          if (other.AdcMultiplierOverride != 0F) {
            AdcMultiplierOverride = other.AdcMultiplierOverride;
          }
          if (other.WaitBluetoothSecs != 0) {
            WaitBluetoothSecs = other.WaitBluetoothSecs;
          }
          if (other.MeshSdsTimeoutSecs != 0) {
            MeshSdsTimeoutSecs = other.MeshSdsTimeoutSecs;
          }
          if (other.SdsSecs != 0) {
            SdsSecs = other.SdsSecs;
          }
          if (other.LsSecs != 0) {
            LsSecs = other.LsSecs;
          }
          if (other.MinWakeSecs != 0) {
            MinWakeSecs = other.MinWakeSecs;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                IsPowerSaving = input.ReadBool();
                break;
              }
              case 16: {
                OnBatteryShutdownAfterSecs = input.ReadUInt32();
                break;
              }
              case 29: {
                AdcMultiplierOverride = input.ReadFloat();
                break;
              }
              case 32: {
                WaitBluetoothSecs = input.ReadUInt32();
                break;
              }
              case 40: {
                MeshSdsTimeoutSecs = input.ReadUInt32();
                break;
              }
              case 48: {
                SdsSecs = input.ReadUInt32();
                break;
              }
              case 56: {
                LsSecs = input.ReadUInt32();
                break;
              }
              case 64: {
                MinWakeSecs = input.ReadUInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                IsPowerSaving = input.ReadBool();
                break;
              }
              case 16: {
                OnBatteryShutdownAfterSecs = input.ReadUInt32();
                break;
              }
              case 29: {
                AdcMultiplierOverride = input.ReadFloat();
                break;
              }
              case 32: {
                WaitBluetoothSecs = input.ReadUInt32();
                break;
              }
              case 40: {
                MeshSdsTimeoutSecs = input.ReadUInt32();
                break;
              }
              case 48: {
                SdsSecs = input.ReadUInt32();
                break;
              }
              case 56: {
                LsSecs = input.ReadUInt32();
                break;
              }
              case 64: {
                MinWakeSecs = input.ReadUInt32();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      ///
      /// Network Config
      /// </summary>
      public sealed partial class NetworkConfig : pb::IMessage<NetworkConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<NetworkConfig> _parser = new pb::MessageParser<NetworkConfig>(() => new NetworkConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<NetworkConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public NetworkConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public NetworkConfig(NetworkConfig other) : this() {
          wifiEnabled_ = other.wifiEnabled_;
          wifiSsid_ = other.wifiSsid_;
          wifiPsk_ = other.wifiPsk_;
          ntpServer_ = other.ntpServer_;
          ethEnabled_ = other.ethEnabled_;
          ethMode_ = other.ethMode_;
          ipv4Config_ = other.ipv4Config_ != null ? other.ipv4Config_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public NetworkConfig Clone() {
          return new NetworkConfig(this);
        }

        /// <summary>Field number for the "wifi_enabled" field.</summary>
        public const int WifiEnabledFieldNumber = 1;
        private bool wifiEnabled_;
        /// <summary>
        ///
        /// Enable WiFi (disables Bluetooth)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool WifiEnabled {
          get { return wifiEnabled_; }
          set {
            wifiEnabled_ = value;
          }
        }

        /// <summary>Field number for the "wifi_ssid" field.</summary>
        public const int WifiSsidFieldNumber = 3;
        private string wifiSsid_ = "";
        /// <summary>
        ///
        /// If set, this node will try to join the specified wifi network and
        /// acquire an address via DHCP
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string WifiSsid {
          get { return wifiSsid_; }
          set {
            wifiSsid_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "wifi_psk" field.</summary>
        public const int WifiPskFieldNumber = 4;
        private string wifiPsk_ = "";
        /// <summary>
        ///
        /// If set, will be use to authenticate to the named wifi
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string WifiPsk {
          get { return wifiPsk_; }
          set {
            wifiPsk_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "ntp_server" field.</summary>
        public const int NtpServerFieldNumber = 5;
        private string ntpServer_ = "";
        /// <summary>
        ///
        /// NTP server to use if WiFi is conneced, defaults to `0.pool.ntp.org`
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string NtpServer {
          get { return ntpServer_; }
          set {
            ntpServer_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "eth_enabled" field.</summary>
        public const int EthEnabledFieldNumber = 6;
        private bool ethEnabled_;
        /// <summary>
        ///
        /// Enable Ethernet
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool EthEnabled {
          get { return ethEnabled_; }
          set {
            ethEnabled_ = value;
          }
        }

        /// <summary>Field number for the "eth_mode" field.</summary>
        public const int EthModeFieldNumber = 7;
        private global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.EthMode ethMode_ = global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.EthMode.Dhcp;
        /// <summary>
        ///
        /// acquire an address via DHCP or assign static
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.EthMode EthMode {
          get { return ethMode_; }
          set {
            ethMode_ = value;
          }
        }

        /// <summary>Field number for the "ipv4_config" field.</summary>
        public const int Ipv4ConfigFieldNumber = 8;
        private global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.IpV4Config ipv4Config_;
        /// <summary>
        ///
        /// struct to keep static address
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.IpV4Config Ipv4Config {
          get { return ipv4Config_; }
          set {
            ipv4Config_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as NetworkConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(NetworkConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (WifiEnabled != other.WifiEnabled) return false;
          if (WifiSsid != other.WifiSsid) return false;
          if (WifiPsk != other.WifiPsk) return false;
          if (NtpServer != other.NtpServer) return false;
          if (EthEnabled != other.EthEnabled) return false;
          if (EthMode != other.EthMode) return false;
          if (!object.Equals(Ipv4Config, other.Ipv4Config)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (WifiEnabled != false) hash ^= WifiEnabled.GetHashCode();
          if (WifiSsid.Length != 0) hash ^= WifiSsid.GetHashCode();
          if (WifiPsk.Length != 0) hash ^= WifiPsk.GetHashCode();
          if (NtpServer.Length != 0) hash ^= NtpServer.GetHashCode();
          if (EthEnabled != false) hash ^= EthEnabled.GetHashCode();
          if (EthMode != global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.EthMode.Dhcp) hash ^= EthMode.GetHashCode();
          if (ipv4Config_ != null) hash ^= Ipv4Config.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (WifiEnabled != false) {
            output.WriteRawTag(8);
            output.WriteBool(WifiEnabled);
          }
          if (WifiSsid.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(WifiSsid);
          }
          if (WifiPsk.Length != 0) {
            output.WriteRawTag(34);
            output.WriteString(WifiPsk);
          }
          if (NtpServer.Length != 0) {
            output.WriteRawTag(42);
            output.WriteString(NtpServer);
          }
          if (EthEnabled != false) {
            output.WriteRawTag(48);
            output.WriteBool(EthEnabled);
          }
          if (EthMode != global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.EthMode.Dhcp) {
            output.WriteRawTag(56);
            output.WriteEnum((int) EthMode);
          }
          if (ipv4Config_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(Ipv4Config);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (WifiEnabled != false) {
            output.WriteRawTag(8);
            output.WriteBool(WifiEnabled);
          }
          if (WifiSsid.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(WifiSsid);
          }
          if (WifiPsk.Length != 0) {
            output.WriteRawTag(34);
            output.WriteString(WifiPsk);
          }
          if (NtpServer.Length != 0) {
            output.WriteRawTag(42);
            output.WriteString(NtpServer);
          }
          if (EthEnabled != false) {
            output.WriteRawTag(48);
            output.WriteBool(EthEnabled);
          }
          if (EthMode != global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.EthMode.Dhcp) {
            output.WriteRawTag(56);
            output.WriteEnum((int) EthMode);
          }
          if (ipv4Config_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(Ipv4Config);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (WifiEnabled != false) {
            size += 1 + 1;
          }
          if (WifiSsid.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(WifiSsid);
          }
          if (WifiPsk.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(WifiPsk);
          }
          if (NtpServer.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(NtpServer);
          }
          if (EthEnabled != false) {
            size += 1 + 1;
          }
          if (EthMode != global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.EthMode.Dhcp) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) EthMode);
          }
          if (ipv4Config_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Ipv4Config);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(NetworkConfig other) {
          if (other == null) {
            return;
          }
          if (other.WifiEnabled != false) {
            WifiEnabled = other.WifiEnabled;
          }
          if (other.WifiSsid.Length != 0) {
            WifiSsid = other.WifiSsid;
          }
          if (other.WifiPsk.Length != 0) {
            WifiPsk = other.WifiPsk;
          }
          if (other.NtpServer.Length != 0) {
            NtpServer = other.NtpServer;
          }
          if (other.EthEnabled != false) {
            EthEnabled = other.EthEnabled;
          }
          if (other.EthMode != global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.EthMode.Dhcp) {
            EthMode = other.EthMode;
          }
          if (other.ipv4Config_ != null) {
            if (ipv4Config_ == null) {
              Ipv4Config = new global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.IpV4Config();
            }
            Ipv4Config.MergeFrom(other.Ipv4Config);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                WifiEnabled = input.ReadBool();
                break;
              }
              case 26: {
                WifiSsid = input.ReadString();
                break;
              }
              case 34: {
                WifiPsk = input.ReadString();
                break;
              }
              case 42: {
                NtpServer = input.ReadString();
                break;
              }
              case 48: {
                EthEnabled = input.ReadBool();
                break;
              }
              case 56: {
                EthMode = (global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.EthMode) input.ReadEnum();
                break;
              }
              case 66: {
                if (ipv4Config_ == null) {
                  Ipv4Config = new global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.IpV4Config();
                }
                input.ReadMessage(Ipv4Config);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                WifiEnabled = input.ReadBool();
                break;
              }
              case 26: {
                WifiSsid = input.ReadString();
                break;
              }
              case 34: {
                WifiPsk = input.ReadString();
                break;
              }
              case 42: {
                NtpServer = input.ReadString();
                break;
              }
              case 48: {
                EthEnabled = input.ReadBool();
                break;
              }
              case 56: {
                EthMode = (global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.EthMode) input.ReadEnum();
                break;
              }
              case 66: {
                if (ipv4Config_ == null) {
                  Ipv4Config = new global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.IpV4Config();
                }
                input.ReadMessage(Ipv4Config);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the NetworkConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          public enum EthMode {
            /// <summary>
            ///
            /// obtain ip address via DHCP
            /// </summary>
            [pbr::OriginalName("DHCP")] Dhcp = 0,
            /// <summary>
            ///
            /// use static ip address
            /// </summary>
            [pbr::OriginalName("STATIC")] Static = 1,
          }

          public sealed partial class IpV4Config : pb::IMessage<IpV4Config>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<IpV4Config> _parser = new pb::MessageParser<IpV4Config>(() => new IpV4Config());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<IpV4Config> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public IpV4Config() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public IpV4Config(IpV4Config other) : this() {
              ip_ = other.ip_;
              gateway_ = other.gateway_;
              subnet_ = other.subnet_;
              dns_ = other.dns_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public IpV4Config Clone() {
              return new IpV4Config(this);
            }

            /// <summary>Field number for the "ip" field.</summary>
            public const int IpFieldNumber = 1;
            private uint ip_;
            /// <summary>
            ///
            /// Static IP address
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public uint Ip {
              get { return ip_; }
              set {
                ip_ = value;
              }
            }

            /// <summary>Field number for the "gateway" field.</summary>
            public const int GatewayFieldNumber = 2;
            private uint gateway_;
            /// <summary>
            ///
            /// Static gateway address
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public uint Gateway {
              get { return gateway_; }
              set {
                gateway_ = value;
              }
            }

            /// <summary>Field number for the "subnet" field.</summary>
            public const int SubnetFieldNumber = 3;
            private uint subnet_;
            /// <summary>
            ///
            /// Static subnet mask
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public uint Subnet {
              get { return subnet_; }
              set {
                subnet_ = value;
              }
            }

            /// <summary>Field number for the "dns" field.</summary>
            public const int DnsFieldNumber = 4;
            private uint dns_;
            /// <summary>
            ///
            /// Static DNS server address
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public uint Dns {
              get { return dns_; }
              set {
                dns_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as IpV4Config);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(IpV4Config other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Ip != other.Ip) return false;
              if (Gateway != other.Gateway) return false;
              if (Subnet != other.Subnet) return false;
              if (Dns != other.Dns) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (Ip != 0) hash ^= Ip.GetHashCode();
              if (Gateway != 0) hash ^= Gateway.GetHashCode();
              if (Subnet != 0) hash ^= Subnet.GetHashCode();
              if (Dns != 0) hash ^= Dns.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (Ip != 0) {
                output.WriteRawTag(13);
                output.WriteFixed32(Ip);
              }
              if (Gateway != 0) {
                output.WriteRawTag(21);
                output.WriteFixed32(Gateway);
              }
              if (Subnet != 0) {
                output.WriteRawTag(29);
                output.WriteFixed32(Subnet);
              }
              if (Dns != 0) {
                output.WriteRawTag(37);
                output.WriteFixed32(Dns);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (Ip != 0) {
                output.WriteRawTag(13);
                output.WriteFixed32(Ip);
              }
              if (Gateway != 0) {
                output.WriteRawTag(21);
                output.WriteFixed32(Gateway);
              }
              if (Subnet != 0) {
                output.WriteRawTag(29);
                output.WriteFixed32(Subnet);
              }
              if (Dns != 0) {
                output.WriteRawTag(37);
                output.WriteFixed32(Dns);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (Ip != 0) {
                size += 1 + 4;
              }
              if (Gateway != 0) {
                size += 1 + 4;
              }
              if (Subnet != 0) {
                size += 1 + 4;
              }
              if (Dns != 0) {
                size += 1 + 4;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(IpV4Config other) {
              if (other == null) {
                return;
              }
              if (other.Ip != 0) {
                Ip = other.Ip;
              }
              if (other.Gateway != 0) {
                Gateway = other.Gateway;
              }
              if (other.Subnet != 0) {
                Subnet = other.Subnet;
              }
              if (other.Dns != 0) {
                Dns = other.Dns;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 13: {
                    Ip = input.ReadFixed32();
                    break;
                  }
                  case 21: {
                    Gateway = input.ReadFixed32();
                    break;
                  }
                  case 29: {
                    Subnet = input.ReadFixed32();
                    break;
                  }
                  case 37: {
                    Dns = input.ReadFixed32();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 13: {
                    Ip = input.ReadFixed32();
                    break;
                  }
                  case 21: {
                    Gateway = input.ReadFixed32();
                    break;
                  }
                  case 29: {
                    Subnet = input.ReadFixed32();
                    break;
                  }
                  case 37: {
                    Dns = input.ReadFixed32();
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

      /// <summary>
      ///
      /// Display Config
      /// </summary>
      public sealed partial class DisplayConfig : pb::IMessage<DisplayConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<DisplayConfig> _parser = new pb::MessageParser<DisplayConfig>(() => new DisplayConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<DisplayConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DisplayConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DisplayConfig(DisplayConfig other) : this() {
          screenOnSecs_ = other.screenOnSecs_;
          gpsFormat_ = other.gpsFormat_;
          autoScreenCarouselSecs_ = other.autoScreenCarouselSecs_;
          compassNorthTop_ = other.compassNorthTop_;
          flipScreen_ = other.flipScreen_;
          units_ = other.units_;
          oled_ = other.oled_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DisplayConfig Clone() {
          return new DisplayConfig(this);
        }

        /// <summary>Field number for the "screen_on_secs" field.</summary>
        public const int ScreenOnSecsFieldNumber = 1;
        private uint screenOnSecs_;
        /// <summary>
        ///
        /// Number of seconds the screen stays on after pressing the user button or receiving a message
        /// 0 for default of one minute MAXUINT for always on
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint ScreenOnSecs {
          get { return screenOnSecs_; }
          set {
            screenOnSecs_ = value;
          }
        }

        /// <summary>Field number for the "gps_format" field.</summary>
        public const int GpsFormatFieldNumber = 2;
        private global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat gpsFormat_ = global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat.Dec;
        /// <summary>
        ///
        /// How the GPS coordinates are formatted on the OLED screen.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat GpsFormat {
          get { return gpsFormat_; }
          set {
            gpsFormat_ = value;
          }
        }

        /// <summary>Field number for the "auto_screen_carousel_secs" field.</summary>
        public const int AutoScreenCarouselSecsFieldNumber = 3;
        private uint autoScreenCarouselSecs_;
        /// <summary>
        ///
        /// Automatically toggles to the next page on the screen like a carousel, based the specified interval in seconds.
        /// Potentially useful for devices without user buttons.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint AutoScreenCarouselSecs {
          get { return autoScreenCarouselSecs_; }
          set {
            autoScreenCarouselSecs_ = value;
          }
        }

        /// <summary>Field number for the "compass_north_top" field.</summary>
        public const int CompassNorthTopFieldNumber = 4;
        private bool compassNorthTop_;
        /// <summary>
        ///
        /// If this is set, the displayed compass will always point north. if unset, the old behaviour 
        /// (top of display is heading direction) is used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool CompassNorthTop {
          get { return compassNorthTop_; }
          set {
            compassNorthTop_ = value;
          }
        }

        /// <summary>Field number for the "flip_screen" field.</summary>
        public const int FlipScreenFieldNumber = 5;
        private bool flipScreen_;
        /// <summary>
        ///
        /// Flip screen vertically, for cases that mount the screen upside down
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool FlipScreen {
          get { return flipScreen_; }
          set {
            flipScreen_ = value;
          }
        }

        /// <summary>Field number for the "units" field.</summary>
        public const int UnitsFieldNumber = 6;
        private global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits units_ = global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits.Metric;
        /// <summary>
        ///
        /// Perferred display units
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits Units {
          get { return units_; }
          set {
            units_ = value;
          }
        }

        /// <summary>Field number for the "oled" field.</summary>
        public const int OledFieldNumber = 7;
        private global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType oled_ = global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType.OledAuto;
        /// <summary>
        ///
        /// Override auto-detect in screen
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType Oled {
          get { return oled_; }
          set {
            oled_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as DisplayConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(DisplayConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ScreenOnSecs != other.ScreenOnSecs) return false;
          if (GpsFormat != other.GpsFormat) return false;
          if (AutoScreenCarouselSecs != other.AutoScreenCarouselSecs) return false;
          if (CompassNorthTop != other.CompassNorthTop) return false;
          if (FlipScreen != other.FlipScreen) return false;
          if (Units != other.Units) return false;
          if (Oled != other.Oled) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (ScreenOnSecs != 0) hash ^= ScreenOnSecs.GetHashCode();
          if (GpsFormat != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat.Dec) hash ^= GpsFormat.GetHashCode();
          if (AutoScreenCarouselSecs != 0) hash ^= AutoScreenCarouselSecs.GetHashCode();
          if (CompassNorthTop != false) hash ^= CompassNorthTop.GetHashCode();
          if (FlipScreen != false) hash ^= FlipScreen.GetHashCode();
          if (Units != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits.Metric) hash ^= Units.GetHashCode();
          if (Oled != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType.OledAuto) hash ^= Oled.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (ScreenOnSecs != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(ScreenOnSecs);
          }
          if (GpsFormat != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat.Dec) {
            output.WriteRawTag(16);
            output.WriteEnum((int) GpsFormat);
          }
          if (AutoScreenCarouselSecs != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(AutoScreenCarouselSecs);
          }
          if (CompassNorthTop != false) {
            output.WriteRawTag(32);
            output.WriteBool(CompassNorthTop);
          }
          if (FlipScreen != false) {
            output.WriteRawTag(40);
            output.WriteBool(FlipScreen);
          }
          if (Units != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits.Metric) {
            output.WriteRawTag(48);
            output.WriteEnum((int) Units);
          }
          if (Oled != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType.OledAuto) {
            output.WriteRawTag(56);
            output.WriteEnum((int) Oled);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (ScreenOnSecs != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(ScreenOnSecs);
          }
          if (GpsFormat != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat.Dec) {
            output.WriteRawTag(16);
            output.WriteEnum((int) GpsFormat);
          }
          if (AutoScreenCarouselSecs != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(AutoScreenCarouselSecs);
          }
          if (CompassNorthTop != false) {
            output.WriteRawTag(32);
            output.WriteBool(CompassNorthTop);
          }
          if (FlipScreen != false) {
            output.WriteRawTag(40);
            output.WriteBool(FlipScreen);
          }
          if (Units != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits.Metric) {
            output.WriteRawTag(48);
            output.WriteEnum((int) Units);
          }
          if (Oled != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType.OledAuto) {
            output.WriteRawTag(56);
            output.WriteEnum((int) Oled);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (ScreenOnSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ScreenOnSecs);
          }
          if (GpsFormat != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat.Dec) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) GpsFormat);
          }
          if (AutoScreenCarouselSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(AutoScreenCarouselSecs);
          }
          if (CompassNorthTop != false) {
            size += 1 + 1;
          }
          if (FlipScreen != false) {
            size += 1 + 1;
          }
          if (Units != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits.Metric) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Units);
          }
          if (Oled != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType.OledAuto) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Oled);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(DisplayConfig other) {
          if (other == null) {
            return;
          }
          if (other.ScreenOnSecs != 0) {
            ScreenOnSecs = other.ScreenOnSecs;
          }
          if (other.GpsFormat != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat.Dec) {
            GpsFormat = other.GpsFormat;
          }
          if (other.AutoScreenCarouselSecs != 0) {
            AutoScreenCarouselSecs = other.AutoScreenCarouselSecs;
          }
          if (other.CompassNorthTop != false) {
            CompassNorthTop = other.CompassNorthTop;
          }
          if (other.FlipScreen != false) {
            FlipScreen = other.FlipScreen;
          }
          if (other.Units != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits.Metric) {
            Units = other.Units;
          }
          if (other.Oled != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType.OledAuto) {
            Oled = other.Oled;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                ScreenOnSecs = input.ReadUInt32();
                break;
              }
              case 16: {
                GpsFormat = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat) input.ReadEnum();
                break;
              }
              case 24: {
                AutoScreenCarouselSecs = input.ReadUInt32();
                break;
              }
              case 32: {
                CompassNorthTop = input.ReadBool();
                break;
              }
              case 40: {
                FlipScreen = input.ReadBool();
                break;
              }
              case 48: {
                Units = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits) input.ReadEnum();
                break;
              }
              case 56: {
                Oled = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType) input.ReadEnum();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                ScreenOnSecs = input.ReadUInt32();
                break;
              }
              case 16: {
                GpsFormat = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat) input.ReadEnum();
                break;
              }
              case 24: {
                AutoScreenCarouselSecs = input.ReadUInt32();
                break;
              }
              case 32: {
                CompassNorthTop = input.ReadBool();
                break;
              }
              case 40: {
                FlipScreen = input.ReadBool();
                break;
              }
              case 48: {
                Units = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits) input.ReadEnum();
                break;
              }
              case 56: {
                Oled = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType) input.ReadEnum();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the DisplayConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          ///
          /// How the GPS coordinates are displayed on the OLED screen.
          /// </summary>
          public enum GpsCoordinateFormat {
            /// <summary>
            ///
            /// GPS coordinates are displayed in the normal decimal degrees format:
            /// DD.DDDDDD DDD.DDDDDD
            /// </summary>
            [pbr::OriginalName("DEC")] Dec = 0,
            /// <summary>
            ///
            /// GPS coordinates are displayed in the degrees minutes seconds format:
            /// DDMM'SS"C DDDMM'SS"C, where C is the compass point representing the locations quadrant
            /// </summary>
            [pbr::OriginalName("DMS")] Dms = 1,
            /// <summary>
            ///
            /// Universal Transverse Mercator format:
            /// ZZB EEEEEE NNNNNNN, where Z is zone, B is band, E is easting, N is northing
            /// </summary>
            [pbr::OriginalName("UTM")] Utm = 2,
            /// <summary>
            ///
            /// Military Grid Reference System format:
            /// ZZB CD EEEEE NNNNN, where Z is zone, B is band, C is the east 100k square, D is the north 100k square,
            /// E is easting, N is northing
            /// </summary>
            [pbr::OriginalName("MGRS")] Mgrs = 3,
            /// <summary>
            ///
            /// Open Location Code (aka Plus Codes).
            /// </summary>
            [pbr::OriginalName("OLC")] Olc = 4,
            /// <summary>
            ///
            /// Ordnance Survey Grid Reference (the National Grid System of the UK).
            /// Format: AB EEEEE NNNNN, where A is the east 100k square, B is the north 100k square,
            /// E is the easting, N is the northing
            /// </summary>
            [pbr::OriginalName("OSGR")] Osgr = 5,
          }

          /// <summary>
          ///
          /// Unit display preference
          /// </summary>
          public enum DisplayUnits {
            /// <summary>
            ///
            /// Metric (Default)
            /// </summary>
            [pbr::OriginalName("METRIC")] Metric = 0,
            /// <summary>
            ///
            /// Imperial
            /// </summary>
            [pbr::OriginalName("IMPERIAL")] Imperial = 1,
          }

          /// <summary>
          ///
          /// Override OLED outo detect with this if it fails.
          /// </summary>
          public enum OledType {
            /// <summary>
            ///
            /// Default / Auto
            /// </summary>
            [pbr::OriginalName("OLED_AUTO")] OledAuto = 0,
            /// <summary>
            ///
            /// Default / Auto
            /// </summary>
            [pbr::OriginalName("OLED_SSD1306")] OledSsd1306 = 1,
            /// <summary>
            ///
            /// Default / Auto
            /// </summary>
            [pbr::OriginalName("OLED_SH1106")] OledSh1106 = 2,
          }

        }
        #endregion

      }

      /// <summary>
      ///
      /// Lora Config
      /// </summary>
      public sealed partial class LoRaConfig : pb::IMessage<LoRaConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LoRaConfig> _parser = new pb::MessageParser<LoRaConfig>(() => new LoRaConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LoRaConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[5]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LoRaConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LoRaConfig(LoRaConfig other) : this() {
          usePreset_ = other.usePreset_;
          modemPreset_ = other.modemPreset_;
          bandwidth_ = other.bandwidth_;
          spreadFactor_ = other.spreadFactor_;
          codingRate_ = other.codingRate_;
          frequencyOffset_ = other.frequencyOffset_;
          region_ = other.region_;
          hopLimit_ = other.hopLimit_;
          txEnabled_ = other.txEnabled_;
          txPower_ = other.txPower_;
          channelNum_ = other.channelNum_;
          overrideDutyCycle_ = other.overrideDutyCycle_;
          ignoreIncoming_ = other.ignoreIncoming_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LoRaConfig Clone() {
          return new LoRaConfig(this);
        }

        /// <summary>Field number for the "use_preset" field.</summary>
        public const int UsePresetFieldNumber = 1;
        private bool usePreset_;
        /// <summary>
        ///
        /// When enabled, the `modem_preset` fields will be adheared to, else the `bandwidth`/`spread_factor`/`coding_rate`
        /// will be taked from their respective manually defined fields
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool UsePreset {
          get { return usePreset_; }
          set {
            usePreset_ = value;
          }
        }

        /// <summary>Field number for the "modem_preset" field.</summary>
        public const int ModemPresetFieldNumber = 2;
        private global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset modemPreset_ = global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset.LongFast;
        /// <summary>
        ///
        /// Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
        /// As a heuristic: If bandwidth is specified, do not use modem_config.
        /// Because protobufs take ZERO space when the value is zero this works out nicely.
        /// This value is replaced by bandwidth/spread_factor/coding_rate.
        /// If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset ModemPreset {
          get { return modemPreset_; }
          set {
            modemPreset_ = value;
          }
        }

        /// <summary>Field number for the "bandwidth" field.</summary>
        public const int BandwidthFieldNumber = 3;
        private uint bandwidth_;
        /// <summary>
        ///
        /// Bandwidth in MHz
        /// Certain bandwidth numbers are 'special' and will be converted to the
        /// appropriate floating point value: 31 -> 31.25MHz
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint Bandwidth {
          get { return bandwidth_; }
          set {
            bandwidth_ = value;
          }
        }

        /// <summary>Field number for the "spread_factor" field.</summary>
        public const int SpreadFactorFieldNumber = 4;
        private uint spreadFactor_;
        /// <summary>
        ///
        /// A number from 7 to 12.
        /// Indicates number of chirps per symbol as 1&lt;&lt;spread_factor.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint SpreadFactor {
          get { return spreadFactor_; }
          set {
            spreadFactor_ = value;
          }
        }

        /// <summary>Field number for the "coding_rate" field.</summary>
        public const int CodingRateFieldNumber = 5;
        private uint codingRate_;
        /// <summary>
        ///
        /// The denominator of the coding rate.
        /// ie for 4/5, the value is 5. 4/8 the value is 8.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint CodingRate {
          get { return codingRate_; }
          set {
            codingRate_ = value;
          }
        }

        /// <summary>Field number for the "frequency_offset" field.</summary>
        public const int FrequencyOffsetFieldNumber = 6;
        private float frequencyOffset_;
        /// <summary>
        ///
        /// This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
        /// A frequency offset that is added to to the calculated band center frequency.
        /// Used to correct for crystal calibration errors.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float FrequencyOffset {
          get { return frequencyOffset_; }
          set {
            frequencyOffset_ = value;
          }
        }

        /// <summary>Field number for the "region" field.</summary>
        public const int RegionFieldNumber = 7;
        private global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode region_ = global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode.Unset;
        /// <summary>
        ///
        /// The region code for the radio (US, CN, EU433, etc...)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode Region {
          get { return region_; }
          set {
            region_ = value;
          }
        }

        /// <summary>Field number for the "hop_limit" field.</summary>
        public const int HopLimitFieldNumber = 8;
        private uint hopLimit_;
        /// <summary>
        ///
        /// Maximum number of hops. This can't be greater than 7.
        /// Default of 3
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint HopLimit {
          get { return hopLimit_; }
          set {
            hopLimit_ = value;
          }
        }

        /// <summary>Field number for the "tx_enabled" field.</summary>
        public const int TxEnabledFieldNumber = 9;
        private bool txEnabled_;
        /// <summary>
        ///
        /// Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
        /// Defaults to false
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool TxEnabled {
          get { return txEnabled_; }
          set {
            txEnabled_ = value;
          }
        }

        /// <summary>Field number for the "tx_power" field.</summary>
        public const int TxPowerFieldNumber = 10;
        private int txPower_;
        /// <summary>
        ///
        /// If zero then, use default max legal continuous power (ie. something that won't
        /// burn out the radio hardware)
        /// In most cases you should use zero here.
        /// Units are in dBm.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int TxPower {
          get { return txPower_; }
          set {
            txPower_ = value;
          }
        }

        /// <summary>Field number for the "channel_num" field.</summary>
        public const int ChannelNumFieldNumber = 11;
        private uint channelNum_;
        /// <summary>
        ///
        /// This is controlling the actual hardware frequency the radio is transmitting on.
        /// Most users should never need to be exposed to this field/concept.
        /// A channel number between 1 and NUM_CHANNELS (whatever the max is in the current region).
        /// If ZERO then the rule is "use the old channel name hash based
        /// algorithm to derive the channel number")
        /// If using the hash algorithm the channel number will be: hash(channel_name) %
        /// NUM_CHANNELS (Where num channels depends on the regulatory region).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint ChannelNum {
          get { return channelNum_; }
          set {
            channelNum_ = value;
          }
        }

        /// <summary>Field number for the "override_duty_cycle" field.</summary>
        public const int OverrideDutyCycleFieldNumber = 12;
        private bool overrideDutyCycle_;
        /// <summary>
        ///
        /// If true, duty cycle limits will be exceeded and thus you're possibly not following 
        /// the local regulations if you're not a HAM.
        /// Has no effect if the duty cycle of the used region is 100%. 
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool OverrideDutyCycle {
          get { return overrideDutyCycle_; }
          set {
            overrideDutyCycle_ = value;
          }
        }

        /// <summary>Field number for the "ignore_incoming" field.</summary>
        public const int IgnoreIncomingFieldNumber = 103;
        private static readonly pb::FieldCodec<uint> _repeated_ignoreIncoming_codec
            = pb::FieldCodec.ForUInt32(826);
        private readonly pbc::RepeatedField<uint> ignoreIncoming_ = new pbc::RepeatedField<uint>();
        /// <summary>
        ///
        /// For testing it is useful sometimes to force a node to never listen to
        /// particular other nodes (simulating radio out of range). All nodenums listed
        /// in ignore_incoming will have packets they send droped on receive (by router.cpp)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<uint> IgnoreIncoming {
          get { return ignoreIncoming_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LoRaConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LoRaConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (UsePreset != other.UsePreset) return false;
          if (ModemPreset != other.ModemPreset) return false;
          if (Bandwidth != other.Bandwidth) return false;
          if (SpreadFactor != other.SpreadFactor) return false;
          if (CodingRate != other.CodingRate) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FrequencyOffset, other.FrequencyOffset)) return false;
          if (Region != other.Region) return false;
          if (HopLimit != other.HopLimit) return false;
          if (TxEnabled != other.TxEnabled) return false;
          if (TxPower != other.TxPower) return false;
          if (ChannelNum != other.ChannelNum) return false;
          if (OverrideDutyCycle != other.OverrideDutyCycle) return false;
          if(!ignoreIncoming_.Equals(other.ignoreIncoming_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (UsePreset != false) hash ^= UsePreset.GetHashCode();
          if (ModemPreset != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset.LongFast) hash ^= ModemPreset.GetHashCode();
          if (Bandwidth != 0) hash ^= Bandwidth.GetHashCode();
          if (SpreadFactor != 0) hash ^= SpreadFactor.GetHashCode();
          if (CodingRate != 0) hash ^= CodingRate.GetHashCode();
          if (FrequencyOffset != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FrequencyOffset);
          if (Region != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode.Unset) hash ^= Region.GetHashCode();
          if (HopLimit != 0) hash ^= HopLimit.GetHashCode();
          if (TxEnabled != false) hash ^= TxEnabled.GetHashCode();
          if (TxPower != 0) hash ^= TxPower.GetHashCode();
          if (ChannelNum != 0) hash ^= ChannelNum.GetHashCode();
          if (OverrideDutyCycle != false) hash ^= OverrideDutyCycle.GetHashCode();
          hash ^= ignoreIncoming_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (UsePreset != false) {
            output.WriteRawTag(8);
            output.WriteBool(UsePreset);
          }
          if (ModemPreset != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset.LongFast) {
            output.WriteRawTag(16);
            output.WriteEnum((int) ModemPreset);
          }
          if (Bandwidth != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(Bandwidth);
          }
          if (SpreadFactor != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(SpreadFactor);
          }
          if (CodingRate != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(CodingRate);
          }
          if (FrequencyOffset != 0F) {
            output.WriteRawTag(53);
            output.WriteFloat(FrequencyOffset);
          }
          if (Region != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode.Unset) {
            output.WriteRawTag(56);
            output.WriteEnum((int) Region);
          }
          if (HopLimit != 0) {
            output.WriteRawTag(64);
            output.WriteUInt32(HopLimit);
          }
          if (TxEnabled != false) {
            output.WriteRawTag(72);
            output.WriteBool(TxEnabled);
          }
          if (TxPower != 0) {
            output.WriteRawTag(80);
            output.WriteInt32(TxPower);
          }
          if (ChannelNum != 0) {
            output.WriteRawTag(88);
            output.WriteUInt32(ChannelNum);
          }
          if (OverrideDutyCycle != false) {
            output.WriteRawTag(96);
            output.WriteBool(OverrideDutyCycle);
          }
          ignoreIncoming_.WriteTo(output, _repeated_ignoreIncoming_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (UsePreset != false) {
            output.WriteRawTag(8);
            output.WriteBool(UsePreset);
          }
          if (ModemPreset != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset.LongFast) {
            output.WriteRawTag(16);
            output.WriteEnum((int) ModemPreset);
          }
          if (Bandwidth != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(Bandwidth);
          }
          if (SpreadFactor != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(SpreadFactor);
          }
          if (CodingRate != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(CodingRate);
          }
          if (FrequencyOffset != 0F) {
            output.WriteRawTag(53);
            output.WriteFloat(FrequencyOffset);
          }
          if (Region != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode.Unset) {
            output.WriteRawTag(56);
            output.WriteEnum((int) Region);
          }
          if (HopLimit != 0) {
            output.WriteRawTag(64);
            output.WriteUInt32(HopLimit);
          }
          if (TxEnabled != false) {
            output.WriteRawTag(72);
            output.WriteBool(TxEnabled);
          }
          if (TxPower != 0) {
            output.WriteRawTag(80);
            output.WriteInt32(TxPower);
          }
          if (ChannelNum != 0) {
            output.WriteRawTag(88);
            output.WriteUInt32(ChannelNum);
          }
          if (OverrideDutyCycle != false) {
            output.WriteRawTag(96);
            output.WriteBool(OverrideDutyCycle);
          }
          ignoreIncoming_.WriteTo(ref output, _repeated_ignoreIncoming_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (UsePreset != false) {
            size += 1 + 1;
          }
          if (ModemPreset != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset.LongFast) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ModemPreset);
          }
          if (Bandwidth != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Bandwidth);
          }
          if (SpreadFactor != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SpreadFactor);
          }
          if (CodingRate != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CodingRate);
          }
          if (FrequencyOffset != 0F) {
            size += 1 + 4;
          }
          if (Region != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode.Unset) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Region);
          }
          if (HopLimit != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HopLimit);
          }
          if (TxEnabled != false) {
            size += 1 + 1;
          }
          if (TxPower != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(TxPower);
          }
          if (ChannelNum != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ChannelNum);
          }
          if (OverrideDutyCycle != false) {
            size += 1 + 1;
          }
          size += ignoreIncoming_.CalculateSize(_repeated_ignoreIncoming_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LoRaConfig other) {
          if (other == null) {
            return;
          }
          if (other.UsePreset != false) {
            UsePreset = other.UsePreset;
          }
          if (other.ModemPreset != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset.LongFast) {
            ModemPreset = other.ModemPreset;
          }
          if (other.Bandwidth != 0) {
            Bandwidth = other.Bandwidth;
          }
          if (other.SpreadFactor != 0) {
            SpreadFactor = other.SpreadFactor;
          }
          if (other.CodingRate != 0) {
            CodingRate = other.CodingRate;
          }
          if (other.FrequencyOffset != 0F) {
            FrequencyOffset = other.FrequencyOffset;
          }
          if (other.Region != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode.Unset) {
            Region = other.Region;
          }
          if (other.HopLimit != 0) {
            HopLimit = other.HopLimit;
          }
          if (other.TxEnabled != false) {
            TxEnabled = other.TxEnabled;
          }
          if (other.TxPower != 0) {
            TxPower = other.TxPower;
          }
          if (other.ChannelNum != 0) {
            ChannelNum = other.ChannelNum;
          }
          if (other.OverrideDutyCycle != false) {
            OverrideDutyCycle = other.OverrideDutyCycle;
          }
          ignoreIncoming_.Add(other.ignoreIncoming_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                UsePreset = input.ReadBool();
                break;
              }
              case 16: {
                ModemPreset = (global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset) input.ReadEnum();
                break;
              }
              case 24: {
                Bandwidth = input.ReadUInt32();
                break;
              }
              case 32: {
                SpreadFactor = input.ReadUInt32();
                break;
              }
              case 40: {
                CodingRate = input.ReadUInt32();
                break;
              }
              case 53: {
                FrequencyOffset = input.ReadFloat();
                break;
              }
              case 56: {
                Region = (global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode) input.ReadEnum();
                break;
              }
              case 64: {
                HopLimit = input.ReadUInt32();
                break;
              }
              case 72: {
                TxEnabled = input.ReadBool();
                break;
              }
              case 80: {
                TxPower = input.ReadInt32();
                break;
              }
              case 88: {
                ChannelNum = input.ReadUInt32();
                break;
              }
              case 96: {
                OverrideDutyCycle = input.ReadBool();
                break;
              }
              case 826:
              case 824: {
                ignoreIncoming_.AddEntriesFrom(input, _repeated_ignoreIncoming_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                UsePreset = input.ReadBool();
                break;
              }
              case 16: {
                ModemPreset = (global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset) input.ReadEnum();
                break;
              }
              case 24: {
                Bandwidth = input.ReadUInt32();
                break;
              }
              case 32: {
                SpreadFactor = input.ReadUInt32();
                break;
              }
              case 40: {
                CodingRate = input.ReadUInt32();
                break;
              }
              case 53: {
                FrequencyOffset = input.ReadFloat();
                break;
              }
              case 56: {
                Region = (global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode) input.ReadEnum();
                break;
              }
              case 64: {
                HopLimit = input.ReadUInt32();
                break;
              }
              case 72: {
                TxEnabled = input.ReadBool();
                break;
              }
              case 80: {
                TxPower = input.ReadInt32();
                break;
              }
              case 88: {
                ChannelNum = input.ReadUInt32();
                break;
              }
              case 96: {
                OverrideDutyCycle = input.ReadBool();
                break;
              }
              case 826:
              case 824: {
                ignoreIncoming_.AddEntriesFrom(ref input, _repeated_ignoreIncoming_codec);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the LoRaConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          public enum RegionCode {
            /// <summary>
            ///
            /// Region is not set
            /// </summary>
            [pbr::OriginalName("UNSET")] Unset = 0,
            /// <summary>
            ///
            /// United States
            /// </summary>
            [pbr::OriginalName("US")] Us = 1,
            /// <summary>
            ///
            /// European Union 433mhz
            /// </summary>
            [pbr::OriginalName("EU_433")] Eu433 = 2,
            /// <summary>
            ///
            /// European Union 433mhz
            /// </summary>
            [pbr::OriginalName("EU_868")] Eu868 = 3,
            /// <summary>
            ///
            /// China
            /// </summary>
            [pbr::OriginalName("CN")] Cn = 4,
            /// <summary>
            ///
            /// Japan
            /// </summary>
            [pbr::OriginalName("JP")] Jp = 5,
            /// <summary>
            ///
            /// Australia / New Zealand
            /// </summary>
            [pbr::OriginalName("ANZ")] Anz = 6,
            /// <summary>
            ///
            /// Korea
            /// </summary>
            [pbr::OriginalName("KR")] Kr = 7,
            /// <summary>
            ///
            /// Taiwan
            /// </summary>
            [pbr::OriginalName("TW")] Tw = 8,
            /// <summary>
            ///
            /// Russia
            /// </summary>
            [pbr::OriginalName("RU")] Ru = 9,
            /// <summary>
            ///
            /// India
            /// </summary>
            [pbr::OriginalName("IN")] In = 10,
            /// <summary>
            ///
            /// New Zealand 865mhz
            /// </summary>
            [pbr::OriginalName("NZ_865")] Nz865 = 11,
            /// <summary>
            ///
            /// Thailand
            /// </summary>
            [pbr::OriginalName("TH")] Th = 12,
            /// <summary>
            ///
            /// WLAN Band
            /// </summary>
            [pbr::OriginalName("LORA_24")] Lora24 = 13,
          }

          /// <summary>
          ///
          /// Standard predefined channel settings
          /// Note: these mappings must match ModemPreset Choice in the device code.
          /// </summary>
          public enum ModemPreset {
            /// <summary>
            ///
            /// Long Range - Fast
            /// </summary>
            [pbr::OriginalName("LONG_FAST")] LongFast = 0,
            /// <summary>
            ///
            /// Long Range - Slow
            /// </summary>
            [pbr::OriginalName("LONG_SLOW")] LongSlow = 1,
            /// <summary>
            ///
            /// Very Long Range - Slow
            /// </summary>
            [pbr::OriginalName("VERY_LONG_SLOW")] VeryLongSlow = 2,
            /// <summary>
            ///
            /// Medium Range - Slow
            /// </summary>
            [pbr::OriginalName("MEDIUM_SLOW")] MediumSlow = 3,
            /// <summary>
            ///
            /// Medium Range - Fast
            /// </summary>
            [pbr::OriginalName("MEDIUM_FAST")] MediumFast = 4,
            /// <summary>
            ///
            /// Short Range - Slow
            /// </summary>
            [pbr::OriginalName("SHORT_SLOW")] ShortSlow = 5,
            /// <summary>
            ///
            /// Short Range - Fast
            /// </summary>
            [pbr::OriginalName("SHORT_FAST")] ShortFast = 6,
          }

        }
        #endregion

      }

      public sealed partial class BluetoothConfig : pb::IMessage<BluetoothConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<BluetoothConfig> _parser = new pb::MessageParser<BluetoothConfig>(() => new BluetoothConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<BluetoothConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[6]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BluetoothConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BluetoothConfig(BluetoothConfig other) : this() {
          enabled_ = other.enabled_;
          mode_ = other.mode_;
          fixedPin_ = other.fixedPin_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BluetoothConfig Clone() {
          return new BluetoothConfig(this);
        }

        /// <summary>Field number for the "enabled" field.</summary>
        public const int EnabledFieldNumber = 1;
        private bool enabled_;
        /// <summary>
        ///
        /// Enable Bluetooth on the device
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Enabled {
          get { return enabled_; }
          set {
            enabled_ = value;
          }
        }

        /// <summary>Field number for the "mode" field.</summary>
        public const int ModeFieldNumber = 2;
        private global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode mode_ = global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode.RandomPin;
        /// <summary>
        ///
        /// Determines the pairing strategy for the device
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode Mode {
          get { return mode_; }
          set {
            mode_ = value;
          }
        }

        /// <summary>Field number for the "fixed_pin" field.</summary>
        public const int FixedPinFieldNumber = 3;
        private uint fixedPin_;
        /// <summary>
        ///
        /// Specified pin for PairingMode.FixedPin
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint FixedPin {
          get { return fixedPin_; }
          set {
            fixedPin_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as BluetoothConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(BluetoothConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Enabled != other.Enabled) return false;
          if (Mode != other.Mode) return false;
          if (FixedPin != other.FixedPin) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Enabled != false) hash ^= Enabled.GetHashCode();
          if (Mode != global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode.RandomPin) hash ^= Mode.GetHashCode();
          if (FixedPin != 0) hash ^= FixedPin.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Enabled != false) {
            output.WriteRawTag(8);
            output.WriteBool(Enabled);
          }
          if (Mode != global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode.RandomPin) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Mode);
          }
          if (FixedPin != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(FixedPin);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Enabled != false) {
            output.WriteRawTag(8);
            output.WriteBool(Enabled);
          }
          if (Mode != global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode.RandomPin) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Mode);
          }
          if (FixedPin != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(FixedPin);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Enabled != false) {
            size += 1 + 1;
          }
          if (Mode != global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode.RandomPin) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Mode);
          }
          if (FixedPin != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FixedPin);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(BluetoothConfig other) {
          if (other == null) {
            return;
          }
          if (other.Enabled != false) {
            Enabled = other.Enabled;
          }
          if (other.Mode != global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode.RandomPin) {
            Mode = other.Mode;
          }
          if (other.FixedPin != 0) {
            FixedPin = other.FixedPin;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Enabled = input.ReadBool();
                break;
              }
              case 16: {
                Mode = (global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode) input.ReadEnum();
                break;
              }
              case 24: {
                FixedPin = input.ReadUInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Enabled = input.ReadBool();
                break;
              }
              case 16: {
                Mode = (global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode) input.ReadEnum();
                break;
              }
              case 24: {
                FixedPin = input.ReadUInt32();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the BluetoothConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          public enum PairingMode {
            /// <summary>
            ///
            /// Device generates a random pin that will be shown on the screen of the device for pairing
            /// </summary>
            [pbr::OriginalName("RANDOM_PIN")] RandomPin = 0,
            /// <summary>
            ///
            /// Device requires a specified fixed pin for pairing
            /// </summary>
            [pbr::OriginalName("FIXED_PIN")] FixedPin = 1,
            /// <summary>
            ///
            /// Device requires no pin for pairing
            /// </summary>
            [pbr::OriginalName("NO_PIN")] NoPin = 2,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
